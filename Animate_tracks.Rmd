---
title: "Penguin movement animation"
author: "Gemma Clucas"
date: "10/14/2020"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(moveVis)
library(move)
library(raster)
library(ggplot2)
library(tidyverse)
library(trip)
library(xts)
library(rgeos)
library(viridis)
```

## Example data 
```{r}
# data("move_data")
# unique(timestamps(move_data))
# timeLag(move_data, unit = "mins")

# move_data <- align_move(move_data, res = 4, unit = "mins")
# 
# frames <- frames_spatial(move_data, path_colours = c("red", "green", "blue"),
#                          map_service = "osm", map_type = "watercolor", alpha = 0.5)
# 
# length(frames)
# frames[[10]]

#animate_frames(frames, out_file = "example.gif")
```

## My data

Load crawled track.
```{r}
# predObj <- read.csv("predicted_tracks/196697_track.csv", stringsAsFactors = FALSE) 

tbl <-
    list.files(path = "predicted_tracks", pattern = "*.csv") %>% 
    map_df(~read_csv(paste0("predicted_tracks/", .)))

# track <- predObj %>%
#   dplyr::filter(locType == "p") %>%                                   # select only predicted positions
#   dplyr::select(Ptt, Time_absolute, Time_since, mu.x, mu.y) %>%       # select only useful colums
#   rename(LON = mu.x, LAT = mu.y) %>%                                 # rename columns for ease of use
#   mutate(time = as.POSIXct(Time_absolute, tz = "UTC"))               # make sure times are in POSIXct

track <- tbl %>%
  dplyr::filter(locType == "p") %>%                                   # select only predicted positions
  dplyr::select(Ptt, Time_absolute, Time_since, mu.x, mu.y) %>%       # select only useful colums
  rename(LON = mu.x, LAT = mu.y) %>%                                 # rename columns for ease of use
  mutate(time = as.POSIXct(Time_absolute, tz = "UTC"))               # make sure times are in POSIXct

# function for adjusting times to make them all unique
make_unique <- function(x) {
  xts::make.time.unique(x$Time_absolute, eps = 5)
}

# apply function
track <- track %>% 
  dplyr::arrange(time, Ptt) %>%                             # order by time, then ID
  dplyr::group_by(time) %>% tidyr::nest() %>%               # nesting makes a list of tibbles containing data for each time stamp
  dplyr::mutate(unique_time = purrr::map(data, make_unique)) %>%      # apply function and save results in new column 'unique_time'
  tidyr::unnest_legacy() %>%                                # this is much faster than unnest() and restores the dataframe
  dplyr::select(-Time_absolute) %>% 
  dplyr::arrange(Ptt, time)


# change to move object
track.move <- track %>% 
  df2move(., 
          proj = CRS("+proj=laea +lon_0=-26 +lat_0=-58 +units=m"), 
          x = "LON", 
          y = "LAT", 
          time = "unique_time",
          track_id = "Ptt")


```

Change the projection to ```WGS 84/EPSG:4326``` so that the axes on the graph are in lat/long. Note that when you create the frames with the ```frames_spatial()``` function, you need to add ```equidistant = F``` to disable this feature.

I actually need a projection that is not in degrees, in order to be able to draw the 12nm buffer around the islands. This is because it is difficult to draw circles in degrees, as they are bigger or smaller depending on where you are on the planet.

So for now, I'm keeping the projection as is.

```{r}
track.move <- sp::spTransform(track.move, crs("+init=epsg:4326"))

track.move.laea <- sp::spTransform(track.move, crs("+proj=laea +lon_0=-26 +lat_0=-58 +units=m"))
```



Align the timestaps among tracks and down-sample to taking a position every 4 hours (240 mins) to reduce the number of frames in the final animation, as it is very slow to make it.

Note: The ```align_move()``` wasn't working until I projected to mercator and back to LAEA... no idea why.
```{r}
# align the time stamps (only need to do when plotting more than one individual)
track.move <- align_move(track.move, res = 240, unit = "mins")

```

Create a buffer around the islands showing the current and proposed extent of the no take zones.
```{r}
# Center of islands - Saunders
b <- data.frame(lat = c(-57.795354), lon = c(-26.465941))

# Tell it it's spatial and in lat/lon
coordinates(b) <- ~ lon + lat
projection(b) <- "+init=epsg:4326"

# Reproject to tracking data projection i.e. Lambert's azimuthal equal area
# b_laea <- spTransform(b, CRS = CRS(projection(track.move)))

# Create buffers around the island
# b_laea_22km <- gBuffer(b_laea, width = 22200)     # 12nm is 22.2 km
# b_laea_50km <- gBuffer(b_laea, width = 50000)     # 50km is the proposed extent

# Create buffers around the island
b_22km <- gBuffer(b, width = 22200)     # 12nm is 22.2 km
b_50km <- gBuffer(b, width = 50000)     # 50km is the proposed extent



```

Create the frames using the ```frames_spatial``` function and then add the buffer zones as polygons using ```add_gg```.

```{r}
frames <- frames_spatial(track.move, 
                         path_colours = viridis(20),
                         map_service = "carto", 
                         map_type = "light", 
                         alpha = 0.5, 
                         equidistant = F) %>% 
  # add_labels(x = "Longitude", y = "Latitude") %>%
  add_scalebar(colour = "black", position = "bottomright", label_margin = 1, units = "km", distance = 100) %>%
  add_timestamps(track.move, type = "label")

# frames = add_gg(frames, 
#                 gg = expr(geom_path(data = b_laea_22km,
#                                     aes(x = b_laea_22km@polygons[[1]]@Polygons[[1]]@coords[,1], 
#                                         y = b_laea_22km@polygons[[1]]@Polygons[[1]]@coords[,2]), 
#                                     colour = "black")))

# frames = add_gg(frames, 
#                 gg = expr(geom_path(data = b_laea_50km,
#                                     aes(x = b_laea_50km@polygons[[1]]@Polygons[[1]]@coords[,1], 
#                                         y = b_laea_50km@polygons[[1]]@Polygons[[1]]@coords[,2]), 
#                                     colour = "black",
#                                     linetype = "dashed")))



# To look at frames individually
frames[[1]]
frames[[150]]

animate_frames(frames, out_file = "AllPtt_LonLAT_res120.gif", overwrite = TRUE)

```

