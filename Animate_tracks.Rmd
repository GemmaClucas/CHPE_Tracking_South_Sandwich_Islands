---
title: "Penguin movement animation"
author: "Gemma Clucas"
date: "10/14/2020"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(moveVis)
library(move)
library(raster)
library(ggplot2)
library(tidyverse)
library(trip)
library(rgeos)

```

## Example data 
```{r}
# data("move_data")
# unique(timestamps(move_data))
# timeLag(move_data, unit = "mins")

# move_data <- align_move(move_data, res = 4, unit = "mins")
# 
# frames <- frames_spatial(move_data, path_colours = c("red", "green", "blue"),
#                          map_service = "osm", map_type = "watercolor", alpha = 0.5)
# 
# length(frames)
# frames[[10]]

#animate_frames(frames, out_file = "example.gif")
```

## My data

Load crawled track.
```{r}
predObj <- read.csv("predicted_tracks/196697_track.csv", stringsAsFactors = FALSE) 

track <- predObj %>%
  dplyr::filter(locType == "p") %>%                                   # select only predicted positions
  dplyr::select(Ptt, Time_absolute, Time_since, mu.x, mu.y) %>%       # select only useful colums
  rename(LON = mu.x, LAT = mu.y) %>%                                 # rename columns for ease of use
  mutate(time = as.POSIXct(Time_absolute, tz = "UTC"))               # make sure times are in POSIXct

# change to move object
track.move <- track %>% 
  df2move(., proj = CRS("+proj=laea +lon_0=-26 +lat_0=-58 +units=m"), x = "LON", y = "LAT", time = "time")

```

Change the projection to ```WGS 84/EPSG:4326``` so that the axes on the graph are in lat/long. Note that when you create the frames with the ```frames_spatial()``` function, you need to add ```equidistant = F``` to disable this feature.

I actually need a projection that is not in degrees, in order to be able to draw the 12nm buffer around the islands. This is because it is difficult to draw circles in degrees, as they are bigger or smaller depending on where you are on the planet.

So for now, I'm keeping the projection as is.

```{r}
#track.move <- sp::spTransform(track.move, crs("+init=epsg:4326"))
```



Align the timestaps among tracks and down-sample to taking a position every 4 hours (240 mins) to reduce the number of frames in the final animation, as it is very slow to make it.
```{r}
# align the time stamps (only need to do when plotting more than one individual)
track.move <- align_move(track.move, res = 240, unit = "mins")

```

Create a buffer around the islands showing the current and proposed extent of the no take zones
```{r}
# Center of islands - Saunders
b <- data.frame(lat = c(-57.795354), lon = c(-26.465941))

# Tell it it's spatial and in lat/lon
coordinates(b) <- ~ lon + lat
projection(b) <- "+init=epsg:4326"

# Reproject to tracking data projection i.e. Lambert's azimuthal equal area
b_laea <- spTransform(b, CRS = CRS(projection(track.move)))

# Create buffers around the island
b_laea_22km <- gBuffer(b_laea, width = 22200)     # 12nm is 22.2 km
b_laea_50km <- gBuffer(b_laea, width = 50000)     # 50km is the proposed extent

```

Create the frames using the ```frames_spatial``` function and then add the buffer zones as polygons using ```add_gg```.

```{r}
frames <- frames_spatial(track.move, 
                         map_service = "carto", 
                         map_type = "light", 
                         alpha = 0.5, 
                         equidistant = F) %>% 
  # add_labels(x = "Longitude", y = "Latitude") %>%
  add_scalebar(colour = "black", position = "bottomright", label_margin = 1, units = "km", distance = 100) %>%
  add_timestamps(track.move, type = "label")

frames = add_gg(frames, 
                gg = expr(geom_path(data = b_laea_22km,
                                    aes(x = b_laea_22km@polygons[[1]]@Polygons[[1]]@coords[,1], 
                                        y = b_laea_22km@polygons[[1]]@Polygons[[1]]@coords[,2]), 
                                    colour = "black")))

frames = add_gg(frames, 
                gg = expr(geom_path(data = b_laea_50km,
                                    aes(x = b_laea_50km@polygons[[1]]@Polygons[[1]]@coords[,1], 
                                        y = b_laea_50km@polygons[[1]]@Polygons[[1]]@coords[,2]), 
                                    colour = "black",
                                    linetype = "dashed")))

# Have a look at a couple of frames
frames[[111]]
frames[[150]]

animate_frames(frames, out_file = "example.gif", overwrite = TRUE)

```

