---
title: "Making predictions from the model"
author: "Gemma Clucas"
date: "5/3/2021"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(raster)
library(rgdal)
library(ncdf4)
library(viridis)
library(mgcv)
library(ggplot2)
library(tidyverse)
```


Read in the data.
```{r}
data <- read.csv(file = "PresBackgroundLocationsWithEnvironmentalVariables.csv", stringsAsFactors = FALSE)
```

Run the final model.
```{r}
GAM <- gam(pres ~ s(colonydist, k = 3) + s(SST, k = 6), data=data, bs="cs", family=binomial, select=TRUE, method='GCV.Cp')

```


### Load map for plotting

Note this is unprojected (WGS84).
```{r}
Seamask<-readOGR("Seamask.shp")
SSI_polygons <- crop(Seamask, c(450000, 1095192, -795043.9, -100000)) %>% 
  spTransform(., crs("+init=epsg:4326"))

# convert to dataframe for use with ggplot2
SSI_polygons@data$id = rownames(SSI_polygons@data)
SSI_polygons.points = fortify(SSI_polygons, region="id")
SSI_polygons.df = plyr::join(SSI_polygons.points, SSI_polygons@data, by="id")

# filter out only the polygons for the islands
SSI_polygons.df <- SSI_polygons.df %>% filter(hole == TRUE)

# plot
SSI_polygons.df %>% 
  ggplot(aes(x = long, y = lat, group = group)) + 
  geom_polygon(fill="grey") +
  geom_path(color="grey") +
  theme_bw() +
  coord_fixed() +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.background = element_rect(fill = "aliceblue"))
```


### 1. Predict around Saunders to check that the distribution looks ok

This just creates a raster across the study area using the bathymetry raster cropped to the right extent.
```{r}
# Read in bathymetry raster and crop to extent of the study area
SSI_bath_WGS84 <- raster("ssi_geotif/full_ssi18a.tif") %>% 
  projectRaster(., crs=crs("+init=epsg:4326")) %>% 
  crop(., c(-27.96598, -24.623, -58.41806, -57.28708))

x <- SSI_bath_WGS84

# Project to LAEA to find extent in metres
y <- projectRaster(x, crs = CRS("+proj=laea +lon_0=-26 +lat_0=-58 +units=m"))
extent(y)
```


Crop out land from the bathymetry raster using ```mask()``` 
```{r}
# Read in shapefile for land
SSI_WGS84 <- readOGR("Seamask.shp") %>% 
  crop(., c(450000, 1095192, -795043.9, -100000)) %>% 
  spTransform(., crs("+init=epsg:4326"))

# Cut out land
mask <- mask(x, SSI_WGS84, inverse=F)

# Plot to check
# plot(mask, col=viridis(100))
# plot(mask, xlim = c(-26.6, -26.2), ylim = c(-57.9, -57.7), col=viridis(100))
```




Make a raster for the distance from colony for Saunders.
```{r}
colony_lat<- -57.808 
colony_lon<- -26.404

# Find the colony cell in the study area raster
j <- cellFromXY(mask, cbind(colony_lon, colony_lat))
# Change the value of the cell where the colony is to 2 (all the other cells are 1)
mask[j]<-2 


# Create a distance raster from the colony
# Moving through land is prevented by omiting cells with NA values
dist <- gridDistance(mask, origin=2, omit=NA)
plot(dist, col=viridis(100))
plot(dist, xlim = c(-26.6, -26.2), ylim = c(-57.9, -57.7), col=viridis(100))
```


Get the sea surface temperature data that I downloaded previously.
```{r}
# Open data - note there is a dataset for Jan and one for Feb
nc_data_Jan <- nc_open('global-analysis-forecast-phy-001-024-monthly_January2020.nc')
nc_data_Feb <- nc_open('global-analysis-forecast-phy-001-024-monthly_February2020.nc')
# Extract longs and lats
nc_lon <- ncvar_get(nc_data_Jan, "longitude")
nc_lat <- ncvar_get(nc_data_Jan, "latitude", verbose = F)
# Create an array of the SST data
temp.array.Jan <- ncvar_get(nc_data_Jan, "thetao")
temp.array.Feb <- ncvar_get(nc_data_Feb, "thetao")
# Take just the surface layer
surface.temp.Jan <- temp.array.Jan[, , 1] 
surface.temp.Feb <- temp.array.Feb[, , 1] 
# Make it into a raster
SST_Jan <- raster(t(surface.temp.Jan), 
                   xmn=min(nc_lon), 
                   xmx=max(nc_lon), 
                   ymn=min(nc_lat), 
                   ymx=max(nc_lat), 
                   crs=crs("+init=epsg:4326")) %>% 
  flip(., direction = "y")
# Same for Feb
SST_Feb <- raster(t(surface.temp.Feb), 
                   xmn=min(nc_lon), 
                   xmx=max(nc_lon), 
                   ymn=min(nc_lat), 
                   ymx=max(nc_lat), 
                   crs=crs("+init=epsg:4326")) %>% 
  flip(., direction = "y")
# Calculate weighted mean (weighting by the number of observations in January vs February)
wMeanSST <- stack(c(SST_Jan, SST_Feb)) %>% 
  weighted.mean(., w = c(0.64, 0.36))
# Plot for study area
raster::plot(wMeanSST, xlim = c(-27.96598, -24.623), ylim = c(-58.41806, -57.28708), col=viridis(100))
```


Make a new raster with a 1km x 1km resolution and use this to sample the distance and SST rasters. The values for the max and min long/lat are from converting the depth raster to LAEA after cropping it to the study area extent (above).
```{r}
long <- seq(-119511.7 , 83876.27, 1000) #first minimum longitude in m, then max, 1000 is 1km
# head(long)
lat <- seq(-49280.75, 80319.25, 1000)
# head(lat)
Saunders_1KmPoints <- expand.grid(long,lat)
names(Saunders_1KmPoints) <- c("Lon","Lat")
# make it spatial
coordinates(Saunders_1KmPoints) <- ~Lon+Lat
proj4string(Saunders_1KmPoints) <- CRS("+proj=laea +lon_0=-26 +lat_0=-58 +units=m")


# change it back to wgs84 to extract the environmental data (those layers are WGS84)
Saunders_1KmPoints <- spTransform(Saunders_1KmPoints, CRS = proj4string(dist))


# sample the distance and SST layers
Saunders_1KmPoints$SST <- raster::extract(wMeanSST, Saunders_1KmPoints)
Saunders_1KmPoints$colonydist <- raster::extract(dist, Saunders_1KmPoints)

```

Make predictions.
```{r}
Saunders_1KmPoints$GAM_pred <- as.numeric(predict(GAM, type="response", newdata = Saunders_1KmPoints))
```

Make a new raster with the correct resolution and extent of the 1km grid, then use it to convert ```Saunders_1KmPoints``` into a raster for plotting.
```{r}
# new raster in LAEA
r <- raster(ncols = 204, nrows = 130, crs = CRS("+proj=laea +lon_0=-26 +lat_0=-58 +units=m")) 
# define the extent of the raster
extent(r) <- c(-119511.7 , 83876.27, -49280.75, 80319.25  )
# change points into LAEA as well
Saunders_1KmPoints <- spTransform(Saunders_1KmPoints, CRS = "+proj=laea +lon_0=-26 +lat_0=-58 +units=m")
# rasterize the predicted values
r3 <- rasterize(Saunders_1KmPoints, r, 'GAM_pred', fun=mean)
# project back to WGS84 for plotting
r3 <- projectRaster(from = r3, to = dist)
#plot(r3, col=viridis(100))


# convert to a df for plotting in two steps,
# First, to a SpatialPointsDataFrame
r3_pts <- rasterToPoints(r3, spatial = TRUE)
# Then to a 'conventional' dataframe
r3_df  <- data.frame(r3_pts)
rm(r3_pts)

ggplot() +
  geom_raster(data = r3_df , aes(x = x, y = y, fill = layer)) + 
  scale_fill_viridis() +
  geom_polygon(data = SSI_polygons.df, aes(x = long, y = lat, group = group), fill = "white") +
  ggtitle("Predicted distribution around Saunders Island") +
  coord_fixed(ratio = 1,
                xlim = c(-27.96598, -24.623),
                ylim = c(-58.41806, -57.28708),
                expand = TRUE,
                clip = "on")
```

The low resolution of the SST data is making the prediction quite pixelated. Also, the missing values where the island is do not quite match the actual location of the island. I have checked and re-checked the projections, and I think this is just a problem with the underlying data, unfortunately.

Can I interpolate the SST data to make it smoother and fill in the gap to the north of the island? I am using the distance from colony raster layer to interpolate the SST layer. I tried both the bilinear and nearest neighbour method for interpolation, and the bilinear method gave a much smoother distribution.

```{r}
# plot the orignal data
plot(wMeanSST, xlim = c(-27.96598, -24.623), ylim = c(-58.41806, -57.28708))
# plot the interpolated data
resample(x = wMeanSST, y = dist, method = 'bilinear') %>% plot(xlim = c(-27.96598, -24.623), ylim = c(-58.41806, -57.28708))


```

This looks pretty good. Save and use for the model.
```{r}
wMeanSST_resampled <- resample(x = wMeanSST, y = dist, method = 'bilinear')
# change points back to WGS84
Saunders_1KmPoints <- spTransform(Saunders_1KmPoints, CRS = proj4string(wMeanSST))
# sample the points for the predicted distribtion
Saunders_1KmPoints$SST <- raster::extract(wMeanSST_resampled, Saunders_1KmPoints)
# rerun the GAM
Saunders_1KmPoints$GAM_pred <- as.numeric(predict(GAM, type="response", newdata = Saunders_1KmPoints))
# rasterize the predicted values (r is already in LAEA so must transform Saunders_1KmPoints)
Saunders_1KmPoints <- spTransform(Saunders_1KmPoints, CRS = proj4string(r))
r3 <- rasterize(Saunders_1KmPoints, r, 'GAM_pred', fun=mean)
# project back to WGS84 for plotting
r3 <- projectRaster(from = r3, to = dist)
#plot(r3, col=viridis(100))

# convert to a df for plotting in two steps,
# First, to a SpatialPointsDataFrame
r3_pts <- rasterToPoints(r3, spatial = TRUE)
# Then to a 'conventional' dataframe
r3_df  <- data.frame(r3_pts)
rm(r3_pts)

ggplot() +
  geom_raster(data = r3_df , aes(x = x, y = y, fill = layer)) + 
  scale_fill_viridis() +
  geom_polygon(data = SSI_polygons.df, aes(x = long, y = lat, group = group), fill = "white") +
  ggtitle("Predicted distribution around Saunders Island after interpolating SST") +
  coord_fixed(ratio = 1,
                xlim = c(-27.96598, -24.623),
                ylim = c(-58.41806, -57.28708),
                expand = TRUE,
                clip = "on")

```


What is the actual distribution of the data?
```{r}
All <- read.csv("Chick-rearing_trips/All_chick-rearing_trips.csv", stringsAsFactors = FALSE) 
# Make it spatial
coordinates(All) <- ~LON + LAT
proj4string(All) <- CRS("+proj=laea +lon_0=-26 +lat_0=-58 +units=m")
# Reproject to WGS84
All <- spTransform(All, CRS = CRS("+proj=longlat +ellps=WGS84"))


ggplot() +
  geom_density_2d_filled(data = as.data.frame(All), aes(x = LON, y = LAT), bins = 20) +
  geom_polygon(data = SSI_polygons.df, aes(x = long, y = lat, group = group), fill = "white") +
  theme_bw() +
  coord_fixed(ratio = 1,
                xlim = c(-27.96598, -24.623),
                ylim = c(-58.41806, -57.28708),
                expand = TRUE,
                clip = "on") +
  ggtitle("Observed distribution around Saunders Island") +
  xlab("Lat") +
  ylab("Long") +
  theme(legend.position = "none")



```


### 2. Zavodovski

Make raster for entire chain of islands using the bathymetry raster as a starting point.

```{r}
SSI_bath_WGS84 <- raster("ssi_geotif/full_ssi18a.tif") %>% 
  projectRaster(., crs=crs("+init=epsg:4326")) %>% 
  crop(., c(-30, -25, -60, -56))

# Read in shapefile for land
SSI_WGS84 <- readOGR("Seamask.shp") %>% 
  crop(., c(450000, 1095192, -795043.9, -100000)) %>% 
  spTransform(., crs("+init=epsg:4326"))

# Cut out land
mask <- mask(SSI_bath_WGS84, SSI_WGS84, inverse=F)

# Plot to check
plot(mask, col=viridis(100))

# Set all values to 1
x <- mask
values(x) <- 1
# Cut out land
x <- mask(x, SSI_WGS84, inverse=F)

# Plot to check
plot(x, col=viridis(100))
```

Make a raster of the distances from colonies on Zavodovski.
```{r}
Zav1_lat<- -56.291598
Zav1_lon<- -27.600711

# Find the colony cell in the study area raster
j <- cellFromXY(x, cbind(Zav1_lon, Zav1_lat))
# Change the value of the cell where the colony is to 2 (all the other cells are 1)
x[j]<-2 


# Create a distance raster from the colony
# Moving through land is prevented by omiting cells with NA values
dist <- gridDistance(x, origin=2, omit=NA)
plot(dist, col=viridis(100))
```

Add a second colony on Thule.
```{r}
Thule1_lat <- -59.464498
Thule1_lon <- -27.307218

# Find the colony cell in the study area raster
j <- cellFromXY(x, cbind(Thule1_lon, Thule1_lat))
# Change the value of the cell where the colony is to 2 (all the other cells are 1)
x[j] <- 2 


# Create a distance raster from the colony
# Moving through land is prevented by omiting cells with NA values
dist <- gridDistance(x, origin=2, omit=NA)
plot(dist, col=viridis(100))
```
So I can calculate the distance from more than one colony at once.


Read in colony locations on Zavodovski
```{r}
colonies <- read.csv("Colony_LatLons.csv", header = TRUE)
coordinates(colonies) <- ~Long+Lat

j <- cellFromXY(x, colonies)
x[j] <- 2 

# Create a distance raster from the colony
dist <- gridDistance(x, origin=2, omit=NA)
plot(dist, col=viridis(100), xlim = c(-27.7, -27.4), ylim = c(-56.4, -56.2))

```

That looks like it working fine. There isn't a jumping in point in the northeast of the island as far we know, and the distance raster reflects this.